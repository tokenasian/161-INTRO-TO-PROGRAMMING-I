import time

# TODO add params onto Ant init for the size of the board and for the starting ant position


class Ant:
    direction = 0
    move = 0

    def __init__(self):
        self._size_x = 3
        self._size_y = 3
        self._direction = 0
        self._initial_grid = [[0] * self._size_x for i in range(self._size_y)]

    def render(self, _ant_x, _ant_y, _grid=None):
        if _grid is None:
            _grid = self._initial_grid
        _grid[_ant_x][_ant_y] = 8
        for x in _grid:
            for y in x:
                white = "_"
                #white = "　"
                #black = "#"
                black = "#"
                cur_pos = "8"
                #cur_pos = "●"
                if y == 0 and y != 8:
                    position = white
                elif y == 8:
                    position = cur_pos
                else:
                    position = black
                print(position, end="")
            print(end="\n")

    def turn_right(self, input):
        x = 0
        output = input + 1
        if input == 3:
            return x
        return output

    def turn_left(self, input, _grid):
        y = 3
        output = input - 1
        if input == 0:
            return y
        return output

    def move_ant(self, new_ant_x, new_ant_y):
            if new_ant_x <= 0:
                new_ant_x = self._size_x - 1
            if new_ant_x >= self._size_x + 1
            if new_ant_y <= 0:
                new_ant_y = self._size_x - 1
            if new_ant_y >= self._size_y + 1




ant = Ant()

# TODO move these or something similar into the class later
# movement functions to debug


def move_up(_ant_x, _ant_y):
    new_x = _ant_x - 1
    new_y = _ant_y
    return[new_x, new_y]


def move_right(_ant_x, _ant_y):
    new_x = _ant_x
    new_y = _ant_y + 1
    return[new_x, new_y]


def move_down(_ant_x, _ant_y):
    new_x = _ant_x + 1
    new_y = _ant_y
    return[new_x, new_y]


def move_left(_ant_x, _ant_y):
    new_x = _ant_x
    new_y = _ant_y - 1
    return[new_x, new_y]
# end of movement functions to debug


# print("current coords are",
#       f'[{ant_x},{ant_y}] up coordinates are {move_up(ant_x, ant_y)}')
grid = ant._initial_grid


ant_x = 1
ant_y = 1

rand_x = ant_x
rand_y = ant_y
grid[rand_x][rand_y] = 1 if grid[rand_x][rand_y] == 0 else 0

print("")
print("=====Init=Loc=====")
ant.render(ant_x, ant_y, grid)

time.sleep(0.5)
print("")
print("=====Moved=Up=====")
ant_moved_up = move_up(ant_x, ant_y)
grid[rand_x][rand_y] = 1 if grid[rand_x][rand_y] != 1 else 0
ant.render(ant_moved_up[0], ant_moved_up[1], grid)

time.sleep(0.5)
print("")
print("====Moved=Down====")
# reset grid
grid = [[0] * 3 for i in range(3)]
# end of reset grid
ant_moved_down = move_down(ant_x, ant_y)
grid[1][1] = 1
ant.render(ant_moved_down[0], ant_moved_down[1], grid)

time.sleep(0.5)
print("")
print("====Moved=Left====")
# reset grid
grid = [[0] * 3 for i in range(3)]
# end of reset grid
ant_moved_left = move_left(ant_x, ant_y)
grid[1][1] = 1
ant.render(ant_moved_left[0], ant_moved_left[1], grid)


time.sleep(0.5)
print("")
print("====Moved=Right===")
# reset grid
grid = [[0] * 3 for i in range(3)]
# end of reset grid
ant_moved_right = move_right(ant_x, ant_y)
grid[1][1] = 1
ant.render(ant_moved_right[0], ant_moved_right[1], grid)
